<!DOCTYPE html>
<html>

	<head>
		<meta charset="UTF-8">
		<title>二叉树算法</title>
		<style type="text/css">
			body {
				word-break: break-word;
			}
		</style>
	</head>

	<body>

		<script type="text/javascript">
			function BinaryTree() {
				//创建节点
				var Node = function(key) {
					this.key = key; //数值
					this.left = null; //左节点
					this.rigth = null; //右节点
				}

				var root = null; //根节点

				//二叉树插入节点逻辑
				var insertNode = function(node, newNode) {
					if(newNode.key < node.key) { //新结点小于老节点 就插入老结点的左边
						if(node.left === null) { // 老结点的左结点为空的时候，直接插入
							node.left = newNode;
						} else { //老结点的左节点不为空的时候，再次执行insertNode()
							insertNode(node.left, newNode);
						}
					} else {
						if(node.rigth === null) {
							node.rigth = newNode;
						} else {
							insertNode(node.rigth, newNode);
						}
					}
				}
				//插入节点
				this.insert = function(key) {
					var newNode = new Node(key);
					if(root === null) {
						root = newNode;
					} else {
						insertNode(root, newNode);
					}
				}
				//打印中间开始
				//中序遍历  一直找结点最左边的节点，本身没有左节点，就打印自己，然后右节点再按同样原理执行
				var inOrderTraverseNode = function(node, callback) {
					if(node !== null) {
						//一直查找左节点有没有值
						inOrderTraverseNode(node.left, callback);
						//左节点没有值了，就直接打印本身
						callback(node.key);
						//再按以上同理执行右边节点
						inOrderTraverseNode(node.rigth, callback);
					}
				}
				//中序遍历
				this.inOrderTraverse = function(callback) {
					//一开始传入根节点进去
					inOrderTraverseNode(root, callback);
				}
				//打印左节点开始
				//前序遍历  进入直接打印节点，然后进入左节点，直接打印，然后再进入左节点，直到没有左节点，然后进入右节点，直接打印，同理
				var prevOrderTraverseNode = function(node, callback) {
					if(node !== null) {
						callback(node.key);
						prevOrderTraverseNode(node.left, callback);
						prevOrderTraverseNode(node.rigth, callback);
					}
				}

				//前序遍历 
				this.prevOrderTraverse = function(callback) {
					prevOrderTraverseNode(root, callback);
				}
				//最后打印自己
				//后序遍历 
				var postOrderTraverseNode = function(node, callback) {
					if(node !== null) {
						postOrderTraverseNode(node.left, callback);
						postOrderTraverseNode(node.rigth, callback);
						callback(node.key);
					}
				}

				//后序遍历 
				this.postOrderTraverse = function(callback) {
					postOrderTraverseNode(root, callback);
				}

			}
			var nodes = [8, 3, 10, 1, 6, 14, 4, 7, 13];
			var binaryTree = new BinaryTree();
			nodes.forEach(function(key, index) {
				binaryTree.insert(key);
			});
			var arr = [];
			var callback = function(key) {
				arr.push(key);
			}
			//中序遍历
			//			binaryTree.inOrderTraverse(callback);
			//前序遍历
			//			binaryTree.prevOrderTraverse(callback);
			//后序遍历
			binaryTree.postOrderTraverse(callback);
			console.log(arr);
		</script>
	</body>

</html>